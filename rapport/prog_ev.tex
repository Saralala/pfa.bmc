\subsection{Programmation évenementielle}

La programmation événementielle est la base de tout programme interactif.
Il fonctionne sur le principe \textit{action \rightarrow réaction}. L'exemple 
immédiat est le clic sur un bouton (\textit{action}) qui déclenche (\textit{réaction}) 
l'appel à une fonction, dite \textit{CALLBACK}.

GTK+ gère lui-même ces différentes actions (signaux) pour tous les widgets.
Ceux-ci captent l'action de l'utilisateur (\textit{e.g} le clic}), émettent 
un signal, GTK+ reçoit le signal et sait alors quelle fonction \textit{CALLBACK} 
appeller.

La tâche du développeur est grandement simplifiée par l'utilisation des 
bibliothèques GTK+ : la fonction à utiliser a pour prototype
\begin{verbatim}
gulong g_signal_connect(gpointer *object, const gchar *name, GCallback func, gpointer func_data);
\end{verbatim}
où 
\begin{itemize}
\item $object$ est un pointer vers le widget contenant le bouton (\textit{e.g} $G_OBJECT(editor->window)$) ;
\item $name$ est le nom de l'évènement (\textit{e.g} $"destroy"$) ;
\item $func$ est la fonction \textit{CALLBACK} (\textit{e.g} $G_CALLBACK(gtk_main_quit)$) ;
\item $func_data$ est un paramètre donné à $func$.
\end{itemize}

\\

Une autre méthode permet d'associer le clic d'un bouton à une action.
Dans le cadre d'une boîte de dialoque proposant plusieurs choix (\textit{e.g} : Voulez-vous 
sauvegarder avant de quitter ?), la création de ce $dialog$ permet au développeur de décrire son 
fonctionnement. Suite à la création d'un nouveau widget $dialog$, contenant les boutons OUI et NON 
$GTK_BUTTONS_YES_NO$, il suffit de lancer ce widget et stocker sa valeur de retour dans une variable :
\begin{verbatim}
	gint resp=gtk_dialog_run (GTK_DIALOG (dialog));
\end{verbatim}
Il ne reste plus qu'à dissocier :
\begin{verbatim}
	if ( resp == GTK_RESPONSE_YES)
		_save();
	else if( resp == GTK_RESPONSE_NO)
		_quit();
\end{verbatim}

